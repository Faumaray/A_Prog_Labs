//! SeaORM Entity. Generated by sea-orm-codegen 0.3.2

pub mod prelude;

pub mod history;
pub mod user_history;

use sea_orm::*;
use dotenv::dotenv;
use chrono::naive::NaiveDateTime;
use std::env;


pub async fn estabilish_connection() -> DatabaseConnection {
    dotenv().ok();
    let database_url = env::var("CHAT_DATABASE_URL")
        .expect("DATABASE_URL must be set");
    Database::connect(database_url).await.unwrap()
}

pub async fn get_history_by_time(connection: &DatabaseConnection, start: NaiveDateTime, end: NaiveDateTime) -> Result<Vec<(history::Model, Vec<user_history::Model>)>, DbErr>{
    history::Entity::find()
        .find_with_related(user_history::Entity)
        .filter(Condition::all()
                .add(user_history::Column::Timeof.gte(start))
                .add(user_history::Column::Timeof.lte(end)))
        .all(connection).await
}
pub async fn check_id(connection: &DatabaseConnection, id: i32) -> Result<Option<history::Model>, DbErr>{
    history::Entity::find_by_id(id).one(connection).await
}

pub async fn add_to_history(connection: &DatabaseConnection, id: i32, name: String, content: String, time: NaiveDateTime) -> Result<(), DbErr>
{
    if let Some(_history) = history::Entity::find_by_id(id).one(connection).await?
    {
        let user_history = user_history::ActiveModel{
            content: Set(content.to_owned()),
            timeof: Set(time.to_owned()),
            userid: Set(id.to_owned()),
            ..Default::default()
        };
        user_history::Entity::insert(user_history).exec(connection).await?;
    }
    else
    {
        let history = history::ActiveModel{
            client_name: Set(name.clone().to_owned()),
            id: Set(id.clone().to_owned())
        };
        let user_history = user_history::ActiveModel{
            content: Set(content.to_owned()),
            timeof: Set(time.to_owned()),
            userid: Set(id.to_owned()),
            ..Default::default()
        };
        history::Entity::insert(history).exec(connection).await?;
        user_history::Entity::insert(user_history).exec(connection).await?;
    }
    Ok(())
}